/*
 * linux/arch/arm/mach-tegra/pinmux-t11-tables.c
 *
 * Common pinmux configurations for Tegra11x SoCs
 *
 * Copyright (C) 2011-2012 NVIDIA Corporation
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/errno.h>
#include <linux/of.h>
#include <linux/spinlock.h>
#include <linux/syscore_ops.h>
#include <linux/io.h>

#include "gpio-names.h"
#include "iomap.h"

#undef CONFIG_ARCH_TEGRA_2x_SOC
#define TEGRA_PINMUX_HAS_IO_DIRECTION 1
#define TEGRA_GPIO_INVALID	-1

enum tegra_pingroup {
	TEGRA_PINGROUP_ULPI_DATA0,
	TEGRA_PINGROUP_ULPI_DATA1,
	TEGRA_PINGROUP_ULPI_DATA2,
	TEGRA_PINGROUP_ULPI_DATA3,
	TEGRA_PINGROUP_ULPI_DATA4,
	TEGRA_PINGROUP_ULPI_DATA5,
	TEGRA_PINGROUP_ULPI_DATA6,
	TEGRA_PINGROUP_ULPI_DATA7,
	TEGRA_PINGROUP_ULPI_CLK,
	TEGRA_PINGROUP_ULPI_DIR,
	TEGRA_PINGROUP_ULPI_NXT,
	TEGRA_PINGROUP_ULPI_STP,
	TEGRA_PINGROUP_DAP3_FS,
	TEGRA_PINGROUP_DAP3_DIN,
	TEGRA_PINGROUP_DAP3_DOUT,
	TEGRA_PINGROUP_DAP3_SCLK,
	TEGRA_PINGROUP_GPIO_PV0,
	TEGRA_PINGROUP_GPIO_PV1,
	TEGRA_PINGROUP_SDMMC1_CLK,
	TEGRA_PINGROUP_SDMMC1_CMD,
	TEGRA_PINGROUP_SDMMC1_DAT3,
	TEGRA_PINGROUP_SDMMC1_DAT2,
	TEGRA_PINGROUP_SDMMC1_DAT1,
	TEGRA_PINGROUP_SDMMC1_DAT0,
	TEGRA_PINGROUP_CLK2_OUT,
	TEGRA_PINGROUP_CLK2_REQ,
	TEGRA_PINGROUP_HDMI_INT,
	TEGRA_PINGROUP_DDC_SCL,
	TEGRA_PINGROUP_DDC_SDA,
	TEGRA_PINGROUP_UART2_RXD,
	TEGRA_PINGROUP_UART2_TXD,
	TEGRA_PINGROUP_UART2_RTS_N,
	TEGRA_PINGROUP_UART2_CTS_N,
	TEGRA_PINGROUP_UART3_TXD,
	TEGRA_PINGROUP_UART3_RXD,
	TEGRA_PINGROUP_UART3_CTS_N,
	TEGRA_PINGROUP_UART3_RTS_N,
	TEGRA_PINGROUP_GPIO_PU0,
	TEGRA_PINGROUP_GPIO_PU1,
	TEGRA_PINGROUP_GPIO_PU2,
	TEGRA_PINGROUP_GPIO_PU3,
	TEGRA_PINGROUP_GPIO_PU4,
	TEGRA_PINGROUP_GPIO_PU5,
	TEGRA_PINGROUP_GPIO_PU6,
	TEGRA_PINGROUP_GEN1_I2C_SDA,
	TEGRA_PINGROUP_GEN1_I2C_SCL,
	TEGRA_PINGROUP_DAP4_FS,
	TEGRA_PINGROUP_DAP4_DIN,
	TEGRA_PINGROUP_DAP4_DOUT,
	TEGRA_PINGROUP_DAP4_SCLK,
	TEGRA_PINGROUP_CLK3_OUT,
	TEGRA_PINGROUP_CLK3_REQ,
	TEGRA_PINGROUP_GMI_WP_N,
	TEGRA_PINGROUP_GMI_IORDY,
	TEGRA_PINGROUP_GMI_WAIT,
	TEGRA_PINGROUP_GMI_ADV_N,
	TEGRA_PINGROUP_GMI_CLK,
	TEGRA_PINGROUP_GMI_CS0_N,
	TEGRA_PINGROUP_GMI_CS1_N,
	TEGRA_PINGROUP_GMI_CS2_N,
	TEGRA_PINGROUP_GMI_CS3_N,
	TEGRA_PINGROUP_GMI_CS4_N,
	TEGRA_PINGROUP_GMI_CS6_N,
	TEGRA_PINGROUP_GMI_CS7_N,
	TEGRA_PINGROUP_GMI_AD0,
	TEGRA_PINGROUP_GMI_AD1,
	TEGRA_PINGROUP_GMI_AD2,
	TEGRA_PINGROUP_GMI_AD3,
	TEGRA_PINGROUP_GMI_AD4,
	TEGRA_PINGROUP_GMI_AD5,
	TEGRA_PINGROUP_GMI_AD6,
	TEGRA_PINGROUP_GMI_AD7,
	TEGRA_PINGROUP_GMI_AD8,
	TEGRA_PINGROUP_GMI_AD9,
	TEGRA_PINGROUP_GMI_AD10,
	TEGRA_PINGROUP_GMI_AD11,
	TEGRA_PINGROUP_GMI_AD12,
	TEGRA_PINGROUP_GMI_AD13,
	TEGRA_PINGROUP_GMI_AD14,
	TEGRA_PINGROUP_GMI_AD15,
	TEGRA_PINGROUP_GMI_A16,
	TEGRA_PINGROUP_GMI_A17,
	TEGRA_PINGROUP_GMI_A18,
	TEGRA_PINGROUP_GMI_A19,
	TEGRA_PINGROUP_GMI_WR_N,
	TEGRA_PINGROUP_GMI_OE_N,
	TEGRA_PINGROUP_GMI_DQS_P,
	TEGRA_PINGROUP_GMI_DQS = TEGRA_PINGROUP_GMI_DQS_P,
	TEGRA_PINGROUP_GMI_RST_N,
	TEGRA_PINGROUP_GEN2_I2C_SCL,
	TEGRA_PINGROUP_GEN2_I2C_SDA,
	TEGRA_PINGROUP_SDMMC4_CLK,
	TEGRA_PINGROUP_SDMMC4_CMD,
	TEGRA_PINGROUP_SDMMC4_DAT0,
	TEGRA_PINGROUP_SDMMC4_DAT1,
	TEGRA_PINGROUP_SDMMC4_DAT2,
	TEGRA_PINGROUP_SDMMC4_DAT3,
	TEGRA_PINGROUP_SDMMC4_DAT4,
	TEGRA_PINGROUP_SDMMC4_DAT5,
	TEGRA_PINGROUP_SDMMC4_DAT6,
	TEGRA_PINGROUP_SDMMC4_DAT7,
	TEGRA_PINGROUP_SDMMC4_RST_N,
	TEGRA_PINGROUP_CAM_MCLK,
	TEGRA_PINGROUP_GPIO_PCC1,
	TEGRA_PINGROUP_GPIO_PBB0,
	TEGRA_PINGROUP_CAM_I2C_SCL,
	TEGRA_PINGROUP_CAM_I2C_SDA,
	TEGRA_PINGROUP_GPIO_PBB3,
	TEGRA_PINGROUP_GPIO_PBB4,
	TEGRA_PINGROUP_GPIO_PBB5,
	TEGRA_PINGROUP_GPIO_PBB6,
	TEGRA_PINGROUP_GPIO_PBB7,
	TEGRA_PINGROUP_GPIO_PCC2,
	TEGRA_PINGROUP_JTAG_RTCK,
	TEGRA_PINGROUP_PWR_I2C_SCL,
	TEGRA_PINGROUP_PWR_I2C_SDA,
	TEGRA_PINGROUP_KB_ROW0,
	TEGRA_PINGROUP_KB_ROW1,
	TEGRA_PINGROUP_KB_ROW2,
	TEGRA_PINGROUP_KB_ROW3,
	TEGRA_PINGROUP_KB_ROW4,
	TEGRA_PINGROUP_KB_ROW5,
	TEGRA_PINGROUP_KB_ROW6,
	TEGRA_PINGROUP_KB_ROW7,
	TEGRA_PINGROUP_KB_ROW8,
	TEGRA_PINGROUP_KB_ROW9,
	TEGRA_PINGROUP_KB_ROW10,
	TEGRA_PINGROUP_KB_COL0,
	TEGRA_PINGROUP_KB_COL1,
	TEGRA_PINGROUP_KB_COL2,
	TEGRA_PINGROUP_KB_COL3,
	TEGRA_PINGROUP_KB_COL4,
	TEGRA_PINGROUP_KB_COL5,
	TEGRA_PINGROUP_KB_COL6,
	TEGRA_PINGROUP_KB_COL7,
	TEGRA_PINGROUP_CLK_32K_OUT,
	TEGRA_PINGROUP_SYS_CLK_REQ,
	TEGRA_PINGROUP_CORE_PWR_REQ,
	TEGRA_PINGROUP_CPU_PWR_REQ,
	TEGRA_PINGROUP_PWR_INT_N,
	TEGRA_PINGROUP_CLK_32K_IN,
	TEGRA_PINGROUP_OWR,
	TEGRA_PINGROUP_DAP1_FS,
	TEGRA_PINGROUP_DAP1_DIN,
	TEGRA_PINGROUP_DAP1_DOUT,
	TEGRA_PINGROUP_DAP1_SCLK,
	TEGRA_PINGROUP_CLK1_REQ,
	TEGRA_PINGROUP_CLK1_OUT,
	TEGRA_PINGROUP_SPDIF_IN,
	TEGRA_PINGROUP_SPDIF_OUT,
	TEGRA_PINGROUP_DAP2_FS,
	TEGRA_PINGROUP_DAP2_DIN,
	TEGRA_PINGROUP_DAP2_DOUT,
	TEGRA_PINGROUP_DAP2_SCLK,
	TEGRA_PINGROUP_DVFS_PWM,
	TEGRA_PINGROUP_GPIO_X1_AUD,
	TEGRA_PINGROUP_GPIO_X3_AUD,
	TEGRA_PINGROUP_DVFS_CLK,
	TEGRA_PINGROUP_GPIO_X4_AUD,
	TEGRA_PINGROUP_GPIO_X5_AUD,
	TEGRA_PINGROUP_GPIO_X6_AUD,
	TEGRA_PINGROUP_GPIO_X7_AUD,
	TEGRA_PINGROUP_SDMMC3_CLK,
	TEGRA_PINGROUP_SDMMC3_CMD,
	TEGRA_PINGROUP_SDMMC3_DAT0,
	TEGRA_PINGROUP_SDMMC3_DAT1,
	TEGRA_PINGROUP_SDMMC3_DAT2,
	TEGRA_PINGROUP_SDMMC3_DAT3,
	TEGRA_PINGROUP_HDMI_CEC,
	TEGRA_PINGROUP_SDMMC1_WP_N,
	TEGRA_PINGROUP_SDMMC3_CD_N,
	TEGRA_PINGROUP_GPIO_W2_AUD,
	TEGRA_PINGROUP_GPIO_W3_AUD,
	TEGRA_PINGROUP_USB_VBUS_EN0,
	TEGRA_PINGROUP_USB_VBUS_EN1,
	TEGRA_PINGROUP_SDMMC3_CLK_LB_IN,
	TEGRA_PINGROUP_SDMMC3_CLK_LB_OUT,
	TEGRA_PINGROUP_NAND_GMI_CLK_LB,
	TEGRA_PINGROUP_RESET_OUT_N,
	TEGRA_MAX_PINGROUP,
};

enum tegra_drive_pingroup {
	TEGRA_DRIVE_PINGROUP_AO1 = 0,
	TEGRA_DRIVE_PINGROUP_AO2,
	TEGRA_DRIVE_PINGROUP_AT1,
	TEGRA_DRIVE_PINGROUP_AT2,
	TEGRA_DRIVE_PINGROUP_AT3,
	TEGRA_DRIVE_PINGROUP_AT4,
	TEGRA_DRIVE_PINGROUP_AT5,
	TEGRA_DRIVE_PINGROUP_CDEV1,
	TEGRA_DRIVE_PINGROUP_CDEV2,
	TEGRA_DRIVE_PINGROUP_CSUS,
	TEGRA_DRIVE_PINGROUP_DAP1,
	TEGRA_DRIVE_PINGROUP_DAP2,
	TEGRA_DRIVE_PINGROUP_DAP3,
	TEGRA_DRIVE_PINGROUP_DAP4,
	TEGRA_DRIVE_PINGROUP_DBG,
	TEGRA_DRIVE_PINGROUP_SDIO3,
	TEGRA_DRIVE_PINGROUP_SPI,
	TEGRA_DRIVE_PINGROUP_UAA,
	TEGRA_DRIVE_PINGROUP_UAB,
	TEGRA_DRIVE_PINGROUP_UART2,
	TEGRA_DRIVE_PINGROUP_UART3,
	TEGRA_DRIVE_PINGROUP_SDIO1,
	TEGRA_DRIVE_PINGROUP_CRT,
	TEGRA_DRIVE_PINGROUP_DDC,
	TEGRA_DRIVE_PINGROUP_GMA,
	TEGRA_DRIVE_PINGROUP_GME,
	TEGRA_DRIVE_PINGROUP_GMF,
	TEGRA_DRIVE_PINGROUP_GMG,
	TEGRA_DRIVE_PINGROUP_GMH,
	TEGRA_DRIVE_PINGROUP_OWR,
	TEGRA_DRIVE_PINGROUP_UAD,
	TEGRA_DRIVE_PINGROUP_GPV,
	TEGRA_DRIVE_PINGROUP_DEV3,
	TEGRA_DRIVE_PINGROUP_CEC,
	TEGRA_DRIVE_PINGROUP_AT6,
	TEGRA_DRIVE_PINGROUP_DAP5,
	TEGRA_DRIVE_PINGROUP_VBUS,
	TEGRA_MAX_DRIVE_PINGROUP,
};

#define TEGRA_MUX_LIST \
	TEGRA_MUX(NONE) \
	TEGRA_MUX(AHB_CLK) \
	TEGRA_MUX(APB_CLK) \
	TEGRA_MUX(AUDIO_SYNC) \
	TEGRA_MUX(CRT) \
	TEGRA_MUX(DAP1) \
	TEGRA_MUX(DAP2) \
	TEGRA_MUX(DAP3) \
	TEGRA_MUX(DAP4) \
	TEGRA_MUX(DAP5) \
	TEGRA_MUX(DISPLAYA) \
	TEGRA_MUX(DISPLAYB) \
	TEGRA_MUX(EMC_TEST0_DLL) \
	TEGRA_MUX(EMC_TEST1_DLL) \
	TEGRA_MUX(GMI) \
	TEGRA_MUX(GMI_INT) \
	TEGRA_MUX(HDMI) \
	TEGRA_MUX(I2C1) \
	TEGRA_MUX(I2C2) \
	TEGRA_MUX(I2C3) \
	TEGRA_MUX(IDE) \
	TEGRA_MUX(IRDA) \
	TEGRA_MUX(KBC) \
	TEGRA_MUX(MIO) \
	TEGRA_MUX(MIPI_HS) \
	TEGRA_MUX(NAND) \
	TEGRA_MUX(OSC) \
	TEGRA_MUX(OWR) \
	TEGRA_MUX(PCIE) \
	TEGRA_MUX(PLLA_OUT) \
	TEGRA_MUX(PLLC_OUT1) \
	TEGRA_MUX(PLLM_OUT1) \
	TEGRA_MUX(PLLP_OUT2) \
	TEGRA_MUX(PLLP_OUT3) \
	TEGRA_MUX(PLLP_OUT4) \
	TEGRA_MUX(PWM) \
	TEGRA_MUX(PWR_INTR) \
	TEGRA_MUX(PWR_ON) \
	TEGRA_MUX(RTCK) \
	TEGRA_MUX(SDIO1) \
	TEGRA_MUX(SDIO2) \
	TEGRA_MUX(SDIO3) \
	TEGRA_MUX(SDIO4) \
	TEGRA_MUX(SFLASH) \
	TEGRA_MUX(SPDIF) \
	TEGRA_MUX(SPI1) \
	TEGRA_MUX(SPI2) \
	TEGRA_MUX(SPI2_ALT) \
	TEGRA_MUX(SPI3) \
	TEGRA_MUX(SPI4) \
	TEGRA_MUX(TRACE) \
	TEGRA_MUX(TWC) \
	TEGRA_MUX(UARTA) \
	TEGRA_MUX(UARTB) \
	TEGRA_MUX(UARTC) \
	TEGRA_MUX(UARTD) \
	TEGRA_MUX(UARTE) \
	TEGRA_MUX(ULPI) \
	TEGRA_MUX(VI) \
	TEGRA_MUX(VI_SENSOR_CLK) \
	TEGRA_MUX(XIO) \
	/* End of Tegra2 MUX selectors */ \
	TEGRA_MUX(BLINK) \
	TEGRA_MUX(CEC) \
	TEGRA_MUX(CLK12) \
	TEGRA_MUX(DAP) \
	TEGRA_MUX(DAPSDMMC2) \
	TEGRA_MUX(DDR) \
	TEGRA_MUX(DEV3) \
	TEGRA_MUX(DTV) \
	TEGRA_MUX(VI_ALT1) \
	TEGRA_MUX(VI_ALT2) \
	TEGRA_MUX(VI_ALT3) \
	TEGRA_MUX(EMC_DLL) \
	TEGRA_MUX(EXTPERIPH1) \
	TEGRA_MUX(EXTPERIPH2) \
	TEGRA_MUX(EXTPERIPH3) \
	TEGRA_MUX(GMI_ALT) \
	TEGRA_MUX(HDA) \
	TEGRA_MUX(HSI) \
	TEGRA_MUX(I2C4) \
	TEGRA_MUX(I2C5) \
	TEGRA_MUX(I2CPWR) \
	TEGRA_MUX(I2S0) \
	TEGRA_MUX(I2S1) \
	TEGRA_MUX(I2S2) \
	TEGRA_MUX(I2S3) \
	TEGRA_MUX(I2S4) \
	TEGRA_MUX(NAND_ALT) \
	TEGRA_MUX(POPSDIO4) \
	TEGRA_MUX(POPSDMMC4) \
	TEGRA_MUX(PWM0) \
	TEGRA_MUX(PWM1) \
	TEGRA_MUX(PWM2) \
	TEGRA_MUX(PWM3) \
	TEGRA_MUX(SATA) \
	TEGRA_MUX(SPI5) \
	TEGRA_MUX(SPI6) \
	TEGRA_MUX(SYSCLK) \
	TEGRA_MUX(VGP1) \
	TEGRA_MUX(VGP2) \
	TEGRA_MUX(VGP3) \
	TEGRA_MUX(VGP4) \
	TEGRA_MUX(VGP5) \
	TEGRA_MUX(VGP6) \
	/* End of Tegra3 MUX selectors */ \
	TEGRA_MUX(USB) \
	TEGRA_MUX(SOC) \
	TEGRA_MUX(CPU) \
	TEGRA_MUX(CLK) \
	TEGRA_MUX(PWRON) \
	TEGRA_MUX(PMI) \
	TEGRA_MUX(CLDVFS) \
	TEGRA_MUX(RESET_OUT_N) \
	/* End of Tegra114 MUX selectors */

enum tegra_mux_func {
#define TEGRA_MUX(mux) TEGRA_MUX_##mux,
	TEGRA_MUX_LIST
#undef  TEGRA_MUX
	TEGRA_MUX_SAFE,		/* "Safe" default mux selector */
	TEGRA_MAX_MUX,		/* Number of mux selectors */
	TEGRA_MUX_TEGRA2_LAST = TEGRA_MUX_XIO,
	TEGRA_MUX_TEGRA3_LAST = TEGRA_MUX_VGP6,

	/* Mux selector aliases */
	TEGRA_MUX_I2C    = TEGRA_MUX_I2C1,
	TEGRA_MUX_SDMMC1 = TEGRA_MUX_SDIO1,
	TEGRA_MUX_SDMMC2 = TEGRA_MUX_SDIO2,
	TEGRA_MUX_SDMMC3 = TEGRA_MUX_SDIO3,
	TEGRA_MUX_SDMMC4 = TEGRA_MUX_SDIO4,

	/* Special mux selector values */
	TEGRA_MUX_INVALID = 0x4000,
	TEGRA_MUX_RSVD  = 0x8000,
	TEGRA_MUX_RSVD0 = TEGRA_MUX_RSVD,
	TEGRA_MUX_RSVD1 = 0x8001,
	TEGRA_MUX_RSVD2 = 0x8002,
	TEGRA_MUX_RSVD3 = 0x8003,
	TEGRA_MUX_RSVD4 = 0x8004,
};

enum tegra_pullupdown {
	TEGRA_PUPD_NORMAL = 0,
	TEGRA_PUPD_PULL_DOWN,
	TEGRA_PUPD_PULL_UP,
};

enum tegra_tristate {
	TEGRA_TRI_NORMAL = 0,
	TEGRA_TRI_TRISTATE = 1,
};

enum tegra_pin_io {
	TEGRA_PIN_OUTPUT = 0,
	TEGRA_PIN_INPUT = 1,
};

enum tegra_pin_lock {
	TEGRA_PIN_LOCK_DEFAULT = 0,
	TEGRA_PIN_LOCK_DISABLE,
	TEGRA_PIN_LOCK_ENABLE,
};

enum tegra_pin_od {
	TEGRA_PIN_OD_DEFAULT = 0,
	TEGRA_PIN_OD_DISABLE,
	TEGRA_PIN_OD_ENABLE,
};

enum tegra_pin_ioreset {
	TEGRA_PIN_IO_RESET_DEFAULT = 0,
	TEGRA_PIN_IO_RESET_DISABLE,
	TEGRA_PIN_IO_RESET_ENABLE,
};

enum tegra_pin_rcv_sel {
	TEGRA_PIN_RCV_SEL_DEFAULT = 0,
	TEGRA_PIN_RCV_SEL_NORMAL,
	TEGRA_PIN_RCV_SEL_HIGH,
};

enum tegra_vddio {
	TEGRA_VDDIO_BB = 0,
	TEGRA_VDDIO_LCD,
	TEGRA_VDDIO_VI,
	TEGRA_VDDIO_UART,
	TEGRA_VDDIO_DDR,
	TEGRA_VDDIO_NAND,
	TEGRA_VDDIO_SYS,
	TEGRA_VDDIO_AUDIO,
	TEGRA_VDDIO_SD,
	TEGRA_VDDIO_CAM,
	TEGRA_VDDIO_GMI,
	TEGRA_VDDIO_PEXCTL,
	TEGRA_VDDIO_SDMMC1,
	TEGRA_VDDIO_SDMMC3,
	TEGRA_VDDIO_SDMMC4,
};

struct tegra_pingroup_config {
	int pingroup;
	enum tegra_mux_func	func;
	enum tegra_pullupdown	pupd;
	enum tegra_tristate	tristate;
	enum tegra_pin_io	io;
	enum tegra_pin_lock	lock;
	enum tegra_pin_od	od;
	enum tegra_pin_ioreset	ioreset;
	enum tegra_pin_rcv_sel	rcv_sel;
};

enum tegra_slew {
	TEGRA_SLEW_FASTEST = 0,
	TEGRA_SLEW_FAST,
	TEGRA_SLEW_SLOW,
	TEGRA_SLEW_SLOWEST,
	TEGRA_MAX_SLEW,
};

enum tegra_pull_strength {
	TEGRA_PULL_0 = 0,
	TEGRA_PULL_1,
	TEGRA_PULL_2,
	TEGRA_PULL_3,
	TEGRA_PULL_4,
	TEGRA_PULL_5,
	TEGRA_PULL_6,
	TEGRA_PULL_7,
	TEGRA_PULL_8,
	TEGRA_PULL_9,
	TEGRA_PULL_10,
	TEGRA_PULL_11,
	TEGRA_PULL_12,
	TEGRA_PULL_13,
	TEGRA_PULL_14,
	TEGRA_PULL_15,
	TEGRA_PULL_16,
	TEGRA_PULL_17,
	TEGRA_PULL_18,
	TEGRA_PULL_19,
	TEGRA_PULL_20,
	TEGRA_PULL_21,
	TEGRA_PULL_22,
	TEGRA_PULL_23,
	TEGRA_PULL_24,
	TEGRA_PULL_25,
	TEGRA_PULL_26,
	TEGRA_PULL_27,
	TEGRA_PULL_28,
	TEGRA_PULL_29,
	TEGRA_PULL_30,
	TEGRA_PULL_31,
	TEGRA_PULL_32,
	TEGRA_PULL_33,
	TEGRA_PULL_34,
	TEGRA_PULL_35,
	TEGRA_PULL_36,
	TEGRA_PULL_37,
	TEGRA_PULL_38,
	TEGRA_PULL_39,
	TEGRA_PULL_40,
	TEGRA_PULL_41,
	TEGRA_PULL_42,
	TEGRA_PULL_43,
	TEGRA_PULL_44,
	TEGRA_PULL_45,
	TEGRA_PULL_46,
	TEGRA_PULL_47,
	TEGRA_PULL_48,
	TEGRA_PULL_49,
	TEGRA_PULL_50,
	TEGRA_PULL_51,
	TEGRA_PULL_52,
	TEGRA_PULL_53,
	TEGRA_PULL_54,
	TEGRA_PULL_55,
	TEGRA_PULL_56,
	TEGRA_PULL_57,
	TEGRA_PULL_58,
	TEGRA_PULL_59,
	TEGRA_PULL_60,
	TEGRA_PULL_61,
	TEGRA_PULL_62,
	TEGRA_PULL_63,
	TEGRA_PULL_64,
	TEGRA_PULL_65,
	TEGRA_PULL_66,
	TEGRA_PULL_67,
	TEGRA_PULL_68,
	TEGRA_PULL_69,
	TEGRA_PULL_70,
	TEGRA_PULL_71,
	TEGRA_PULL_72,
	TEGRA_PULL_73,
	TEGRA_PULL_74,
	TEGRA_PULL_75,
	TEGRA_PULL_76,
	TEGRA_PULL_77,
	TEGRA_PULL_78,
	TEGRA_PULL_79,
	TEGRA_PULL_80,
	TEGRA_PULL_81,
	TEGRA_PULL_82,
	TEGRA_PULL_83,
	TEGRA_PULL_84,
	TEGRA_PULL_85,
	TEGRA_PULL_86,
	TEGRA_PULL_87,
	TEGRA_PULL_88,
	TEGRA_PULL_89,
	TEGRA_PULL_90,
	TEGRA_PULL_91,
	TEGRA_PULL_92,
	TEGRA_PULL_93,
	TEGRA_PULL_94,
	TEGRA_PULL_95,
	TEGRA_PULL_96,
	TEGRA_PULL_97,
	TEGRA_PULL_98,
	TEGRA_PULL_99,
	TEGRA_PULL_100,
	TEGRA_PULL_101,
	TEGRA_PULL_102,
	TEGRA_PULL_103,
	TEGRA_PULL_104,
	TEGRA_PULL_105,
	TEGRA_PULL_106,
	TEGRA_PULL_107,
	TEGRA_PULL_108,
	TEGRA_PULL_109,
	TEGRA_PULL_110,
	TEGRA_PULL_111,
	TEGRA_PULL_112,
	TEGRA_PULL_113,
	TEGRA_PULL_114,
	TEGRA_PULL_115,
	TEGRA_PULL_116,
	TEGRA_PULL_117,
	TEGRA_PULL_118,
	TEGRA_PULL_119,
	TEGRA_PULL_120,
	TEGRA_PULL_121,
	TEGRA_PULL_122,
	TEGRA_PULL_123,
	TEGRA_PULL_124,
	TEGRA_PULL_125,
	TEGRA_PULL_126,
	TEGRA_PULL_127,
	TEGRA_MAX_PULL,
};

enum tegra_drive {
	TEGRA_DRIVE_DIV_8 = 0,
	TEGRA_DRIVE_DIV_4,
	TEGRA_DRIVE_DIV_2,
	TEGRA_DRIVE_DIV_1,
	TEGRA_MAX_DRIVE,
};

enum tegra_drive_type {
	TEGRA_DRIVE_TYPE_0 = 0,
	TEGRA_DRIVE_TYPE_1,
	TEGRA_DRIVE_TYPE_2,
	TEGRA_DRIVE_TYPE_3,
	TEGRA_MAX_DRIVE_TYPE,
};

enum tegra_hsm {
	TEGRA_HSM_DISABLE = 0,
	TEGRA_HSM_ENABLE,
};

enum tegra_schmitt {
	TEGRA_SCHMITT_DISABLE = 0,
	TEGRA_SCHMITT_ENABLE,
};

struct tegra_drive_pingroup_config {
	int pingroup;
	enum tegra_hsm hsm;
	enum tegra_schmitt schmitt;
	enum tegra_drive drive;
	enum tegra_pull_strength pull_down;
	enum tegra_pull_strength pull_up;
	enum tegra_slew slew_rising;
	enum tegra_slew slew_falling;
	enum tegra_drive_type drive_type;
};

struct tegra_drive_pingroup_desc {
	const char *name;
	s16 reg_bank;
	s16 reg;
	u8 drvup_offset;
	u16 drvup_mask;
	u8 drvdown_offset;
	u16 drvdown_mask;
	u8 slewrise_offset;
	u16 slewrise_mask;
	u8 slewfall_offset;
	u16 slewfall_mask;
	u8 drvtype_valid;
	u8 drvtype_offset;
	u8 drvtype_mask;
	const char *dev_id;
};

struct tegra_pingroup_desc {
	const char *name;
	int funcs[4];
	int func_safe;
	int vddio;
	enum tegra_pin_io io_default;
	s16 tri_bank;	/* Register bank the tri_reg exists within */
	s16 mux_bank;	/* Register bank the mux_reg exists within */
	s16 pupd_bank;	/* Register bank the pupd_reg exists within */
	s16 tri_reg;	/* offset into the TRISTATE_REG_* register bank */
	s16 mux_reg;	/* offset into the PIN_MUX_CTL_* register bank */
	s16 pupd_reg;	/* offset into the PULL_UPDOWN_REG_* register bank */
	s8 tri_bit;	/* offset into the TRISTATE_REG_* register bit */
	s8 mux_bit;	/* offset into the PIN_MUX_CTL_* register bit */
	s8 pupd_bit;	/* offset into the PULL_UPDOWN_REG_* register bit */
	s8 lock_bit;	/* offset of the LOCK bit into mux register bit */
	s8 od_bit;	/* offset of the OD bit into mux register bit */
	s8 ioreset_bit;	/* offset of the IO_RESET bit into mux register bit */
	s8 rcv_sel_bit;	/* offset of the RCV_SEL bit into mux register bit */
	int gpionr;
};

#define PINGROUP_REG_A	0x0
#define MUXCTL_REG_A	0x0

#define SET_DRIVE_PINGROUP(pg_name, r, drv_down_offset, drv_down_mask,	\
	drv_up_offset, drv_up_mask, slew_rise_offset, slew_rise_mask,	\
	slew_fall_offset, slew_fall_mask, drv_type_valid,		\
	drv_type_offset, drv_type_mask, _dev_id)			\
	[TEGRA_DRIVE_PINGROUP_ ## pg_name] = {			\
		.name = #pg_name,				\
		.reg_bank = 0,					\
		.reg = ((r) - PINGROUP_REG_A),			\
		.drvup_offset = drv_up_offset,			\
		.drvup_mask = drv_up_mask,			\
		.drvdown_offset = drv_down_offset,		\
		.drvdown_mask = drv_down_mask,			\
		.slewrise_offset = slew_rise_offset,		\
		.slewrise_mask = slew_rise_mask,		\
		.slewfall_offset = slew_fall_offset,		\
		.slewfall_mask = slew_fall_mask,		\
		.drvtype_valid = drv_type_valid,		\
		.drvtype_offset = drv_type_offset,		\
		.drvtype_mask = drv_type_mask,			\
		.dev_id = _dev_id,				\
	}

#define DEFAULT_DRIVE_PINGROUP(pg_name, r)		\
	[TEGRA_DRIVE_PINGROUP_ ## pg_name] = {		\
		.name = #pg_name,			\
		.reg_bank = 0,				\
		.reg = ((r) - PINGROUP_REG_A),		\
		.drvup_offset = 20,			\
		.drvup_mask = 0x1f,			\
		.drvdown_offset = 12,			\
		.drvdown_mask = 0x1f,			\
		.slewrise_offset = 28,			\
		.slewrise_mask = 0x3,			\
		.slewfall_offset = 30,			\
		.slewfall_mask = 0x3,			\
		.drvtype_valid = 0,			\
		.drvtype_offset = 6,			\
		.drvtype_mask = 0x3,			\
		.dev_id = NULL				\
	}

const struct tegra_drive_pingroup_desc tegra_soc_drive_pingroups[TEGRA_MAX_DRIVE_PINGROUP] = {
	DEFAULT_DRIVE_PINGROUP(AO1,		0x868),
	DEFAULT_DRIVE_PINGROUP(AO2,		0x86c),
	DEFAULT_DRIVE_PINGROUP(AT1,		0x870),
	DEFAULT_DRIVE_PINGROUP(AT2,		0x874),
	DEFAULT_DRIVE_PINGROUP(AT3,		0x878),
	DEFAULT_DRIVE_PINGROUP(AT4,		0x87c),
	DEFAULT_DRIVE_PINGROUP(AT5,		0x880),
	DEFAULT_DRIVE_PINGROUP(CDEV1,		0x884),
	DEFAULT_DRIVE_PINGROUP(CDEV2,		0x888),
	DEFAULT_DRIVE_PINGROUP(CSUS,		0x88c),
	DEFAULT_DRIVE_PINGROUP(DAP1,		0x890),
	DEFAULT_DRIVE_PINGROUP(DAP2,		0x894),
	DEFAULT_DRIVE_PINGROUP(DAP3,		0x898),
	DEFAULT_DRIVE_PINGROUP(DAP4,		0x89c),
	DEFAULT_DRIVE_PINGROUP(DBG,		0x8a0),
	SET_DRIVE_PINGROUP(SDIO3,		0x8b0,	12,	0x7F,	20,
		0x7F,	28,	0x3,	30,	0x3,	0,	0,	0,
		"sdhci-tegra.2"),
	DEFAULT_DRIVE_PINGROUP(SPI,		0x8b4),
	DEFAULT_DRIVE_PINGROUP(UAA,		0x8b8),
	DEFAULT_DRIVE_PINGROUP(UAB,		0x8bc),
	DEFAULT_DRIVE_PINGROUP(UART2,		0x8c0),
	DEFAULT_DRIVE_PINGROUP(UART3,		0x8c4),
	SET_DRIVE_PINGROUP(SDIO1,		0x8ec,	12,	0x7F,	20,
		0x7F,	28,	0x3,	30,	0x3,	0,	0,	0,
		"sdhci-tegra.0"),
	DEFAULT_DRIVE_PINGROUP(CRT,		0x8f8),
	DEFAULT_DRIVE_PINGROUP(DDC,		0x8fc),
	SET_DRIVE_PINGROUP(GMA,			0x900,	14,	0x1F,	20,
		0x1F,	28,	0x3,	30,	0x3,	1,	6,	0x3,
		"sdhci-tegra.3"),
	DEFAULT_DRIVE_PINGROUP(GME,		0x910),
	DEFAULT_DRIVE_PINGROUP(GMF,		0x914),
	DEFAULT_DRIVE_PINGROUP(GMG,		0x918),
	DEFAULT_DRIVE_PINGROUP(GMH,		0x91c),
	DEFAULT_DRIVE_PINGROUP(OWR,		0x920),
	DEFAULT_DRIVE_PINGROUP(UAD,		0x924),
	DEFAULT_DRIVE_PINGROUP(GPV,		0x928),
	DEFAULT_DRIVE_PINGROUP(DEV3,		0x92c),
	DEFAULT_DRIVE_PINGROUP(CEC,		0x938),
	DEFAULT_DRIVE_PINGROUP(AT6,		0x994),
	DEFAULT_DRIVE_PINGROUP(DAP5,		0x998),
	DEFAULT_DRIVE_PINGROUP(VBUS,		0x99C),
};

#define PINGROUP(pg_name, gpio_nr, vdd, f0, f1, f2, f3, fs, iod, reg)	\
	[TEGRA_PINGROUP_ ## pg_name] = {			\
		.name = #pg_name,				\
		.vddio = TEGRA_VDDIO_ ## vdd,			\
		.funcs = {					\
			TEGRA_MUX_ ## f0,			\
			TEGRA_MUX_ ## f1,			\
			TEGRA_MUX_ ## f2,			\
			TEGRA_MUX_ ## f3,			\
		},						\
		.gpionr = TEGRA_GPIO_ ## gpio_nr,		\
		.func_safe = TEGRA_MUX_ ## fs,			\
		.tri_bank = 1,					\
		.tri_reg = ((reg) - MUXCTL_REG_A),		\
		.tri_bit = 4,					\
		.mux_bank = 1,					\
		.mux_reg = ((reg) - MUXCTL_REG_A),		\
		.mux_bit = 0,					\
		.pupd_bank = 1,					\
		.pupd_reg = ((reg) - MUXCTL_REG_A),		\
		.pupd_bit = 2,					\
		.io_default = TEGRA_PIN_ ## iod,		\
		.od_bit = 6,					\
		.lock_bit = 7,					\
		.ioreset_bit = 8,				\
		.rcv_sel_bit = 9,				\
	}

/* !!!FIXME!!! FILL IN fSafe COLUMN IN TABLE ....... */
#define PINGROUPS	\
	/*       NAME		  GPIO		VDD	    f0		f1          f2          f3           fSafe       io	reg */\
	PINGROUP(ULPI_DATA0,	  PO1,		BB,	    SPI3,	HSI,	    UARTA,	ULPI,	     RSVD,	INPUT,	0x3000),\
	PINGROUP(ULPI_DATA1,	  PO2,		BB,	    SPI3,	HSI,	    UARTA,	ULPI,	     RSVD,	INPUT,	0x3004),\
	PINGROUP(ULPI_DATA2,	  PO3,		BB,	    SPI3,	HSI,	    UARTA,	ULPI,	     RSVD,	INPUT,	0x3008),\
	PINGROUP(ULPI_DATA3,	  PO4,		BB,	    SPI3,	HSI,	    UARTA,	ULPI,	     RSVD,	INPUT,	0x300c),\
	PINGROUP(ULPI_DATA4,	  PO5,		BB,	    SPI2,	HSI,	    UARTA,	ULPI,	     RSVD,	INPUT,	0x3010),\
	PINGROUP(ULPI_DATA5,	  PO6,		BB,	    SPI2,	HSI,	    UARTA,	ULPI,	     RSVD,	INPUT,	0x3014),\
	PINGROUP(ULPI_DATA6,	  PO7,		BB,	    SPI2,	HSI,	    UARTA,	ULPI,	     RSVD,	INPUT,	0x3018),\
	PINGROUP(ULPI_DATA7,	  PO0,		BB,	    SPI2,	HSI,	    UARTA,	ULPI,	     RSVD,	INPUT,	0x301c),\
	PINGROUP(ULPI_CLK,	  PY0,		BB,	    SPI1,	SPI5,	    UARTD,	ULPI,	     RSVD,	INPUT,	0x3020),\
	PINGROUP(ULPI_DIR,	  PY1,		BB,	    SPI1,	SPI5,	    UARTD,	ULPI,	     RSVD,	INPUT,	0x3024),\
	PINGROUP(ULPI_NXT,	  PY2,		BB,	    SPI1,	SPI5,	    UARTD,	ULPI,	     RSVD,	INPUT,	0x3028),\
	PINGROUP(ULPI_STP,	  PY3,		BB,	    SPI1,	SPI5,	    UARTD,	ULPI,	     RSVD,	INPUT,	0x302c),\
	PINGROUP(DAP3_FS,	  PP0,		BB,	    I2S2,	SPI5,	    RSVD2,	RSVD3,       RSVD,	INPUT,	0x3030),\
	PINGROUP(DAP3_DIN,	  PP1,		BB,	    I2S2,	SPI5,	    RSVD2,	RSVD3,       RSVD,	INPUT,	0x3034),\
	PINGROUP(DAP3_DOUT,	  PP2,		BB,	    I2S2,	SPI5,	    RSVD2,	RSVD3,       RSVD,	INPUT,	0x3038),\
	PINGROUP(DAP3_SCLK,	  PP3,		BB,	    I2S2,	SPI5,	    RSVD2,	RSVD3,       RSVD,	INPUT,	0x303c),\
	PINGROUP(GPIO_PV0,	  PV0,		BB,	    USB,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3040),\
	PINGROUP(GPIO_PV1,	  PV1,		BB,	    RSVD0,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3044),\
	PINGROUP(SDMMC1_CLK,	  PZ0,		SDMMC1,     SDMMC1,	CLK12,	    RSVD2,	RSVD3,       RSVD,	INPUT,	0x3048),\
	PINGROUP(SDMMC1_CMD,	  PZ1,		SDMMC1,     SDMMC1,	SPDIF,	    SPI4,	UARTA,       RSVD,	INPUT,	0x304c),\
	PINGROUP(SDMMC1_DAT3,	  PY4,		SDMMC1,     SDMMC1,	SPDIF,	    SPI4,	UARTA,       RSVD,	INPUT,	0x3050),\
	PINGROUP(SDMMC1_DAT2,	  PY5,		SDMMC1,     SDMMC1,	PWM0,	    SPI4,	UARTA,       RSVD,	INPUT,	0x3054),\
	PINGROUP(SDMMC1_DAT1,	  PY6,		SDMMC1,     SDMMC1,	PWM1,	    SPI4,	UARTA,       RSVD,	INPUT,	0x3058),\
	PINGROUP(SDMMC1_DAT0,	  PY7,		SDMMC1,     SDMMC1,	RSVD1,	    SPI4,	UARTA,       RSVD,	INPUT,	0x305c),\
	PINGROUP(CLK2_OUT,	  PW5,		SDMMC1,     EXTPERIPH2,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3068),\
	PINGROUP(CLK2_REQ,	  PCC5,		SDMMC1,     DAP,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x306c),\
	PINGROUP(HDMI_INT,	  PN7,		LCD,	    RSVD0,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3110),\
	PINGROUP(DDC_SCL,	  PV4,		LCD,	    I2C4,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3114),\
	PINGROUP(DDC_SDA,	  PV5,		LCD,	    I2C4,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3118),\
	PINGROUP(UART2_RXD,	  PC3,		UART,	    IRDA,	SPDIF,	    UARTA,	SPI4,	     RSVD,	INPUT,	0x3164),\
	PINGROUP(UART2_TXD,	  PC2,		UART,	    IRDA,	SPDIF,	    UARTA,	SPI4,	     RSVD,	INPUT,	0x3168),\
	PINGROUP(UART2_RTS_N,	  PJ6,		UART,	    UARTA,	UARTB,	    RSVD2,	SPI4,	     RSVD,	INPUT,	0x316c),\
	PINGROUP(UART2_CTS_N,	  PJ5,		UART,	    UARTA,	UARTB,	    RSVD2,	SPI4,	     RSVD,	INPUT,	0x3170),\
	PINGROUP(UART3_TXD,	  PW6,		UART,	    UARTC,	RSVD1,	    RSVD2,	SPI4,	     RSVD,	INPUT,	0x3174),\
	PINGROUP(UART3_RXD,	  PW7,		UART,	    UARTC,	RSVD1,	    RSVD2,	SPI4,	     RSVD,	INPUT,	0x3178),\
	PINGROUP(UART3_CTS_N,	  PA1,		UART,	    UARTC,	SDMMC1,	    DTV,	SPI4,	     RSVD,	INPUT,	0x317c),\
	PINGROUP(UART3_RTS_N,	  PC0,          UART,	    UARTC,	PWM0,	    DTV,	DISPLAYA,    RSVD,	INPUT,	0x3180),\
	PINGROUP(GPIO_PU0,	  PU0,          UART,	    RSVD0,	UARTA,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3184),\
	PINGROUP(GPIO_PU1,	  PU1,          UART,	    RSVD0,	UARTA,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3188),\
	PINGROUP(GPIO_PU2,	  PU2,          UART,	    RSVD0,	UARTA,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x318c),\
	PINGROUP(GPIO_PU3,	  PU3,          UART,	    PWM0,	UARTA,	    RSVD2,	RSVD3,       RSVD,	INPUT,	0x3190),\
	PINGROUP(GPIO_PU4,	  PU4,          UART,	    PWM1,	UARTA,	    RSVD2,	RSVD3,       RSVD,	INPUT,	0x3194),\
	PINGROUP(GPIO_PU5,	  PU5,          UART,	    PWM2,	UARTA,	    RSVD2,	RSVD3,       RSVD,	INPUT,	0x3198),\
	PINGROUP(GPIO_PU6,	  PU6,          UART,	    PWM3,	UARTA,	    USB,	RSVD3,       RSVD,	INPUT,	0x319c),\
	PINGROUP(GEN1_I2C_SDA,	  PC5,          UART,	    I2C1,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x31a0),\
	PINGROUP(GEN1_I2C_SCL,	  PC4,          UART,	    I2C1,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x31a4),\
	PINGROUP(DAP4_FS,	  PP4,          UART,	    I2S3,	RSVD1,	    DTV,	RSVD3,	     RSVD,	INPUT,	0x31a8),\
	PINGROUP(DAP4_DIN,	  PP5,          UART,	    I2S3,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x31ac),\
	PINGROUP(DAP4_DOUT,	  PP6,          UART,	    I2S3,	RSVD1,	    DTV,	RSVD3,	     RSVD,	INPUT,	0x31b0),\
	PINGROUP(DAP4_SCLK,	  PP7,          UART,	    I2S3,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x31b4),\
	PINGROUP(CLK3_OUT,	  PEE0,		UART,	    EXTPERIPH3,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x31b8),\
	PINGROUP(CLK3_REQ,	  PEE1,		UART,	    DEV3,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x31bc),\
	PINGROUP(GMI_WP_N,	  PC7,		GMI,	    RSVD0,	NAND,	    GMI,	GMI_ALT,     RSVD,	INPUT,	0x31c0),\
	PINGROUP(GMI_IORDY,	  PI5,		GMI,	    SDMMC2,	RSVD1,	    GMI,	RSVD,	     RSVD,	INPUT,	0x31c4),\
	PINGROUP(GMI_WAIT,	  PI7,		GMI,	    SPI4,	NAND,	    GMI,	DTV,	     RSVD,	INPUT,	0x31c8),\
	PINGROUP(GMI_ADV_N,	  PK0,		GMI,	    RSVD0,	NAND,	    GMI,	RSVD,	     RSVD,	INPUT,	0x31cc),\
	PINGROUP(GMI_CLK,	  PK1,		GMI,	    SDMMC2,	NAND,	    GMI,	RSVD,	     RSVD,	INPUT,	0x31d0),\
	PINGROUP(GMI_CS0_N,	  PJ0,		GMI,	    RSVD0,	NAND,	    GMI,	USB,	     RSVD,	INPUT,	0x31d4),\
	PINGROUP(GMI_CS1_N,	  PJ2,		GMI,	    RSVD0,	NAND,	    GMI,	SOC,	     RSVD,	INPUT,	0x31d8),\
	PINGROUP(GMI_CS2_N,	  PK3,		GMI,	    SDMMC2,	NAND,	    GMI,	RSVD,	     RSVD,	INPUT,	0x31dc),\
	PINGROUP(GMI_CS3_N,	  PK4,		GMI,	    SDMMC2,	NAND,	    GMI,	GMI_ALT,     RSVD,	INPUT,	0x31e0),\
	PINGROUP(GMI_CS4_N,	  PK2,		GMI,	    USB,	NAND,	    GMI,	RSVD,	     RSVD,	INPUT,	0x31e4),\
	PINGROUP(GMI_CS6_N,	  PI3,		GMI,	    NAND,	NAND_ALT,   GMI,	SPI4,	     RSVD,	INPUT,	0x31e8),\
	PINGROUP(GMI_CS7_N,	  PI6,		GMI,	    NAND,	NAND_ALT,   GMI,	SDMMC2,	     RSVD,	INPUT,	0x31ec),\
	PINGROUP(GMI_AD0,	  PG0,		GMI,	    RSVD0,	NAND,	    GMI,	RSVD3,	     RSVD,	INPUT,	0x31f0),\
	PINGROUP(GMI_AD1,	  PG1,		GMI,	    RSVD0,	NAND,	    GMI,	RSVD3,	     RSVD,	INPUT,	0x31f4),\
	PINGROUP(GMI_AD2,	  PG2,		GMI,	    RSVD0,	NAND,	    GMI,	RSVD3,	     RSVD,	INPUT,	0x31f8),\
	PINGROUP(GMI_AD3,	  PG3,		GMI,	    RSVD0,	NAND,	    GMI,	RSVD3,	     RSVD,	INPUT,	0x31fc),\
	PINGROUP(GMI_AD4,	  PG4,		GMI,	    RSVD0,	NAND,	    GMI,	RSVD3,	     RSVD,	INPUT,	0x3200),\
	PINGROUP(GMI_AD5,	  PG5,		GMI,	    RSVD0,	NAND,	    GMI,	SPI4,	     RSVD,	INPUT,	0x3204),\
	PINGROUP(GMI_AD6,	  PG6,		GMI,	    RSVD0,	NAND,	    GMI,	SPI4,	     RSVD,	INPUT,	0x3208),\
	PINGROUP(GMI_AD7,	  PG7,		GMI,	    RSVD0,	NAND,	    GMI,	SPI4,	     RSVD,	INPUT,	0x320c),\
	PINGROUP(GMI_AD8,	  PH0,		GMI,	    PWM0,	NAND,	    GMI,	DTV,	     RSVD,	INPUT,	0x3210),\
	PINGROUP(GMI_AD9,	  PH1,		GMI,	    PWM1,	NAND,	    GMI,	CLDVFS,	     RSVD,	INPUT,	0x3214),\
	PINGROUP(GMI_AD10,	  PH2,		GMI,	    PWM2,	NAND,	    GMI,	CLDVFS,	     RSVD,	INPUT,	0x3218),\
	PINGROUP(GMI_AD11,	  PH3,		GMI,	    PWM3,	NAND,	    GMI,	USB,	     RSVD,	INPUT,	0x321c),\
	PINGROUP(GMI_AD12,	  PH4,		GMI,	    SDMMC2,	NAND,	    GMI,	RSVD3,	     RSVD,	INPUT,	0x3220),\
	PINGROUP(GMI_AD13,	  PH5,		GMI,	    SDMMC2,	NAND,	    GMI,	RSVD3,	     RSVD,	INPUT,	0x3224),\
	PINGROUP(GMI_AD14,	  PH6,		GMI,	    SDMMC2,	NAND,	    GMI,	DTV,	     RSVD,	INPUT,	0x3228),\
	PINGROUP(GMI_AD15,	  PH7,		GMI,	    SDMMC2,	NAND,	    GMI,	DTV,	     RSVD,	INPUT,	0x322c),\
	PINGROUP(GMI_A16,	  PJ7,		GMI,	    UARTD,	RSVD,	    GMI,	GMI_ALT,     RSVD,	INPUT,	0x3230),\
	PINGROUP(GMI_A17,	  PB0,		GMI,	    UARTD,	RSVD1,	    GMI,	RSVD,	     RSVD,	INPUT,	0x3234),\
	PINGROUP(GMI_A18,	  PB1,		GMI,	    UARTD,	RSVD1,	    GMI,	RSVD,	     RSVD,	INPUT,	0x3238),\
	PINGROUP(GMI_A19,	  PK7,		GMI,	    UARTD,	SPI4,	    GMI,	RSVD,	     RSVD,	INPUT,	0x323c),\
	PINGROUP(GMI_WR_N,	  PI0,		GMI,	    RSVD0,	NAND,	    GMI,	SPI4,	     RSVD,	INPUT,	0x3240),\
	PINGROUP(GMI_OE_N,	  PI1,		GMI,	    RSVD0,	NAND,	    GMI,	SOC,	     RSVD,	INPUT,	0x3244),\
	PINGROUP(GMI_DQS_P,	  PJ3,		GMI,	    SDMMC2,	NAND,	    GMI,	RSVD,	     RSVD,	INPUT,	0x3248),\
	PINGROUP(GMI_RST_N,	  PI4,		GMI,	    NAND,	NAND_ALT,   GMI,	RSVD3,	     RSVD,	INPUT,	0x324c),\
	PINGROUP(GEN2_I2C_SCL,	  PT5,		GMI,	    I2C2,	RSVD1,      GMI,	RSVD3,	     RSVD,	INPUT,	0x3250),\
	PINGROUP(GEN2_I2C_SDA,	  PT6,		GMI,	    I2C2,	RSVD1,      GMI,	RSVD3,	     RSVD,	INPUT,	0x3254),\
	PINGROUP(SDMMC4_CLK,	  PCC4,		SDMMC4,     SDMMC4,	RSVD1,	    GMI,	RSVD3,	     RSVD,	INPUT,	0x3258),\
	PINGROUP(SDMMC4_CMD,	  PT7,		SDMMC4,     SDMMC4,	RSVD1,	    GMI,	RSVD3,	     RSVD,	INPUT,	0x325c),\
	PINGROUP(SDMMC4_DAT0,	  PAA0,		SDMMC4,     SDMMC4,	SPI3,	    GMI,	RSVD3,	     RSVD,	INPUT,	0x3260),\
	PINGROUP(SDMMC4_DAT1,	  PAA1,		SDMMC4,     SDMMC4,	SPI3,	    GMI,	RSVD3,	     RSVD,	INPUT,	0x3264),\
	PINGROUP(SDMMC4_DAT2,	  PAA2,		SDMMC4,     SDMMC4,	SPI3,	    GMI,	RSVD3,	     RSVD,	INPUT,	0x3268),\
	PINGROUP(SDMMC4_DAT3,	  PAA3,		SDMMC4,     SDMMC4,	SPI3,	    GMI,	RSVD3,	     RSVD,	INPUT,	0x326c),\
	PINGROUP(SDMMC4_DAT4,	  PAA4,		SDMMC4,     SDMMC4,	SPI3,	    GMI,	RSVD3,	     RSVD,	INPUT,	0x3270),\
	PINGROUP(SDMMC4_DAT5,	  PAA5,		SDMMC4,     SDMMC4,	SPI3,	    GMI,	RSVD3,	     RSVD,	INPUT,	0x3274),\
	PINGROUP(SDMMC4_DAT6,	  PAA6,		SDMMC4,     SDMMC4,	SPI3,	    GMI,	RSVD3,	     RSVD,	INPUT,	0x3278),\
	PINGROUP(SDMMC4_DAT7,	  PAA7,		SDMMC4,     SDMMC4,	RSVD1,	    GMI,	RSVD3,	     RSVD,	INPUT,	0x327c),\
	PINGROUP(CAM_MCLK,	  PCC0,		CAM,	    VI,		VI_ALT1,    VI_ALT3,	RSVD3,	     RSVD,	INPUT,	0x3284),\
	PINGROUP(GPIO_PCC1,	  PCC1,		CAM,	    I2S4,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3288),\
	PINGROUP(GPIO_PBB0,	  PBB0,		CAM,	    I2S4,	VI,	    VI_ALT1,	VI_ALT3,     RSVD,	INPUT,	0x328c),\
	PINGROUP(CAM_I2C_SCL,	  PBB1,		CAM,	    VGP1,	I2C3,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3290),\
	PINGROUP(CAM_I2C_SDA,	  PBB2,		CAM,	    VGP2,	I2C3,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3294),\
	PINGROUP(GPIO_PBB3,	  PBB3,		CAM,	    VGP3,	RSVD1,      RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3298),\
	PINGROUP(GPIO_PBB4,	  PBB4,		CAM,	    VGP4,	RSVD1,      RSVD2,	RSVD3,	     RSVD,	INPUT,	0x329c),\
	PINGROUP(GPIO_PBB5,	  PBB5,		CAM,	    VGP5,	RSVD1,      RSVD2,	RSVD3,	     RSVD,	INPUT,	0x32a0),\
	PINGROUP(GPIO_PBB6,	  PBB6,		CAM,	    VGP6,	RSVD1,      RSVD2,	RSVD3,	     RSVD,	INPUT,	0x32a4),\
	PINGROUP(GPIO_PBB7,	  PBB7,		CAM,	    I2S4,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x32a8),\
	PINGROUP(GPIO_PCC2,	  PCC2,		CAM,	    I2S4,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x32ac),\
	PINGROUP(JTAG_RTCK,	  INVALID,	SYS,	    RTCK,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x32b0),\
	PINGROUP(PWR_I2C_SCL,	  PZ6,		SYS,	    I2CPWR,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x32b4),\
	PINGROUP(PWR_I2C_SDA,	  PZ7,		SYS,	    I2CPWR,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x32b8),\
	PINGROUP(KB_ROW0,	  PR0,		SYS,	    KBC,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x32bc),\
	PINGROUP(KB_ROW1,	  PR1,		SYS,	    KBC,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x32c0),\
	PINGROUP(KB_ROW2,	  PR2,		SYS,	    KBC,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x32c4),\
	PINGROUP(KB_ROW3,	  PR3,		SYS,	    KBC,	RSVD1,      RSVD2,	RSVD3,       RSVD,	INPUT,	0x32c8),\
	PINGROUP(KB_ROW4,	  PR4,		SYS,	    KBC,	RSVD1,      SPI2,	RSVD3,       RSVD,	INPUT,	0x32cc),\
	PINGROUP(KB_ROW5,	  PR5,		SYS,	    KBC,	RSVD1,      SPI2,	RSVD3,       RSVD,	INPUT,	0x32d0),\
	PINGROUP(KB_ROW6,	  PR6,		SYS,	    KBC,	RSVD1,      RSVD2,	RSVD3,       RSVD,	INPUT,	0x32d4),\
	PINGROUP(KB_ROW7,	  PR7,		SYS,	    KBC,	RSVD1,	    CLDVFS,	UARTA,	     RSVD,	INPUT,	0x32d8),\
	PINGROUP(KB_ROW8,	  PS0,		SYS,	    KBC,	RSVD1,	    CLDVFS,	UARTA,	     RSVD,	INPUT,	0x32dc),\
	PINGROUP(KB_ROW9,	  PS1,		SYS,	    KBC,	RSVD1,	    RSVD2,	UARTA,	     RSVD,	INPUT,	0x32e0),\
	PINGROUP(KB_ROW10,	  PS2,		SYS,	    KBC,	RSVD1,	    RSVD2,	UARTA,	     RSVD,	INPUT,	0x32e4),\
	PINGROUP(KB_COL0,	  PQ0,	 	SYS,	    KBC,	USB,	    SPI2,	RSVD3,       RSVD,	INPUT,	0x32fc),\
	PINGROUP(KB_COL1,	  PQ1,		SYS,	    KBC,	RSVD1,	    SPI2,	RSVD3,       RSVD,	INPUT,	0x3300),\
	PINGROUP(KB_COL2,	  PQ2,		SYS,	    KBC,	RSVD1,	    SPI2,	RSVD3,	     RSVD,	INPUT,	0x3304),\
	PINGROUP(KB_COL3,	  PQ3,		SYS,	    KBC,	RSVD1,      PWM2,	UARTA,	     RSVD,	INPUT,	0x3308),\
	PINGROUP(KB_COL4,	  PQ4,		SYS,	    KBC,	RSVD1,	    SDMMC3,	UARTA,	     RSVD,	INPUT,	0x330c),\
	PINGROUP(KB_COL5,	  PQ5,		SYS,	    KBC,	RSVD1,	    SDMMC1,	RSVD3,	     RSVD,	INPUT,	0x3310),\
	PINGROUP(KB_COL6,	  PQ6,		SYS,	    KBC,	RSVD1,	    SPI2,	RSVD3,	     RSVD,	INPUT,	0x3314),\
	PINGROUP(KB_COL7,	  PQ7,		SYS,	    KBC,	RSVD1,	    SPI2,	RSVD3,	     RSVD,	INPUT,	0x3318),\
	PINGROUP(CLK_32K_OUT,	  PA0,		SYS,	    BLINK,	SOC,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x331c),\
	PINGROUP(SYS_CLK_REQ,	  PZ5,		SYS,	    SYSCLK,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3320),\
	PINGROUP(CORE_PWR_REQ,	  INVALID,	SYS,	    PWRON,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3324),\
	PINGROUP(CPU_PWR_REQ,	  INVALID,	SYS,	    CPU,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3328),\
	PINGROUP(PWR_INT_N,	  INVALID,	SYS,	    PMI,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x332c),\
	PINGROUP(CLK_32K_IN,	  INVALID,	SYS,	    CLK,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3330),\
	PINGROUP(OWR,		  INVALID,	SYS,	    OWR,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3334),\
	PINGROUP(DAP1_FS,	  PN0,		AUDIO,      I2S0,	HDA,	    GMI,	RSVD3,	     RSVD,	INPUT,	0x3338),\
	PINGROUP(DAP1_DIN,	  PN1,		AUDIO,      I2S0,	HDA,	    GMI,	RSVD3,	     RSVD,	INPUT,	0x333c),\
	PINGROUP(DAP1_DOUT,	  PN2,		AUDIO,      I2S0,	HDA,	    GMI,	RSVD3,	     RSVD,	INPUT,	0x3340),\
	PINGROUP(DAP1_SCLK,	  PN3,		AUDIO,      I2S0,	HDA,	    GMI,	RSVD3,	     RSVD,	INPUT,	0x3344),\
	PINGROUP(CLK1_REQ,	  PEE2,		AUDIO,      DAP,	DAP1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3348),\
	PINGROUP(CLK1_OUT,	  PW4,		AUDIO,      EXTPERIPH1,	DAP2,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x334c),\
	PINGROUP(SPDIF_IN,	  PK6,		AUDIO,      SPDIF,	USB,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3350),\
	PINGROUP(SPDIF_OUT,	  PK5,		AUDIO,      SPDIF,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3354),\
	PINGROUP(DAP2_FS,	  PA2,		AUDIO,      I2S1,	HDA,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3358),\
	PINGROUP(DAP2_DIN,	  PA4,		AUDIO,      I2S1,	HDA,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x335c),\
	PINGROUP(DAP2_DOUT,	  PA5,		AUDIO,      I2S1,	HDA,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3360),\
	PINGROUP(DAP2_SCLK,	  PA3,		AUDIO,      I2S1,	HDA,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3364),\
	PINGROUP(DVFS_PWM,	  PX0,		AUDIO,      SPI6,	CLDVFS,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3368),\
	PINGROUP(GPIO_X1_AUD,	  PX1,		AUDIO,      SPI6,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x336c),\
	PINGROUP(GPIO_X3_AUD,	  PX3,		AUDIO,      SPI6,	SPI1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3370),\
	PINGROUP(DVFS_CLK,	  PX2,		AUDIO,      SPI6,	CLDVFS,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3374),\
	PINGROUP(GPIO_X4_AUD,	  PX4,		AUDIO,      RSVD0,	SPI1,	    SPI2,	DAP2,	     RSVD,	INPUT,	0x3378),\
	PINGROUP(GPIO_X5_AUD,	  PX5,		AUDIO,      RSVD0,	SPI1,	    SPI2,	RSVD3,	     RSVD,	INPUT,	0x337c),\
	PINGROUP(GPIO_X6_AUD,	  PX6,		AUDIO,      SPI6,	SPI1,	    SPI2,	RSVD3,	     RSVD,	INPUT,	0x3380),\
	PINGROUP(GPIO_X7_AUD,	  PX7,		AUDIO,      RSVD0,	SPI1,	    SPI2,	RSVD3,	     RSVD,	INPUT,	0x3384),\
	PINGROUP(SDMMC3_CLK,	  PA6,		SDMMC3,     SDMMC3,	RSVD1,	    RSVD2,	SPI3,	     RSVD,	INPUT,	0x3390),\
	PINGROUP(SDMMC3_CMD,	  PA7,		SDMMC3,     SDMMC3,	PWM3,	    UARTA,	SPI3,	     RSVD,	INPUT,	0x3394),\
	PINGROUP(SDMMC3_DAT0,	  PB7,		SDMMC3,     SDMMC3,	RSVD1,	    RSVD2,	SPI3,	     RSVD,	INPUT,	0x3398),\
	PINGROUP(SDMMC3_DAT1,	  PB6,		SDMMC3,     SDMMC3,	PWM2,	    UARTA,	SPI3,	     RSVD,	INPUT,	0x339c),\
	PINGROUP(SDMMC3_DAT2,	  PB5,		SDMMC3,     SDMMC3,	PWM1,	    DISPLAYA,	SPI3,	     RSVD,	INPUT,	0x33a0),\
	PINGROUP(SDMMC3_DAT3,	  PB4,		SDMMC3,     SDMMC3,	PWM0,	    DISPLAYB,	SPI3,	     RSVD,	INPUT,	0x33a4),\
	PINGROUP(HDMI_CEC, 	  PEE3,		SYS,        CEC,	SDMMC3,	    RSVD2,	SOC,	     RSVD,	INPUT,	0x33e0),\
	PINGROUP(SDMMC1_WP_N,	  PV3,		SDMMC1,     SDMMC1,	CLK12,	    SPI4,	UARTA,	     RSVD,	INPUT,	0x33e4),\
	PINGROUP(SDMMC3_CD_N,	  PV2,		SYS,        SDMMC3,	OWR,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x33e8),\
	PINGROUP(GPIO_W2_AUD,	  PW2,		AUDIO,      SPI6,	RSVD1,	    SPI2,	I2C1,	     RSVD,	INPUT,	0x33ec),\
	PINGROUP(GPIO_W3_AUD,	  PW3,		AUDIO,      SPI6,	SPI1,	    SPI2,	I2C1,	     RSVD,	INPUT,	0x33f0),\
	PINGROUP(USB_VBUS_EN0,	  PN4,		LCD,        USB,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x33f4),\
	PINGROUP(USB_VBUS_EN1,	  PN5,		LCD,        USB,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x33f8),\
	PINGROUP(SDMMC3_CLK_LB_OUT,	  PEE4,		SDMMC3,        SDMMC3,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x33fc),\
	PINGROUP(SDMMC3_CLK_LB_IN,	  PEE5,		SDMMC3,        SDMMC3,	RSVD1,	    RSVD2,	RSVD3,	     RSVD,	INPUT,	0x3400),\
	PINGROUP(RESET_OUT_N,	  INVALID,	SYS,        RSVD0,	RSVD1,	    RSVD2,	RESET_OUT_N, RSVD,	OUTPUT,	0x3408),

static const struct tegra_pingroup_desc tegra_soc_pingroups[TEGRA_MAX_PINGROUP] = {
	PINGROUPS
};

#undef PINGROUP

#undef TEGRA_GPIO_INVALID
#define TEGRA_GPIO_INVALID     TEGRA_MAX_GPIO

#define PINGROUP(pg_name, gpio_nr, vdd, f0, f1, f2, f3, fs, iod, reg)	\
	[TEGRA_GPIO_##gpio_nr] =  TEGRA_PINGROUP_ ##pg_name\

#define HSM_EN(reg)	(((reg) >> 2) & 0x1)
#define SCHMT_EN(reg)	(((reg) >> 3) & 0x1)
#define LPMD(reg)	(((reg) >> 4) & 0x3)
#define DRVDN(reg, offset)	(((reg) >> offset) & 0x1f)
#define DRVUP(reg, offset)	(((reg) >> offset) & 0x1f)
#define SLWR(reg, offset)	(((reg) >> offset) & 0x3)
#define SLWF(reg, offset)	(((reg) >> offset) & 0x3)

static const struct tegra_pingroup_desc *const pingroups = tegra_soc_pingroups;
static const struct tegra_drive_pingroup_desc *const drive_pingroups = tegra_soc_drive_pingroups;

static char *tegra_mux_names[TEGRA_MAX_MUX] = {
#define TEGRA_MUX(mux) [TEGRA_MUX_##mux] = #mux,
	TEGRA_MUX_LIST
#undef  TEGRA_MUX
	[TEGRA_MUX_SAFE] = "<safe>",
};

static const char *tegra_drive_names[TEGRA_MAX_DRIVE] = {
	[TEGRA_DRIVE_DIV_8] = "DIV_8",
	[TEGRA_DRIVE_DIV_4] = "DIV_4",
	[TEGRA_DRIVE_DIV_2] = "DIV_2",
	[TEGRA_DRIVE_DIV_1] = "DIV_1",
};

static const char *tegra_slew_names[TEGRA_MAX_SLEW] = {
	[TEGRA_SLEW_FASTEST] = "FASTEST",
	[TEGRA_SLEW_FAST] = "FAST",
	[TEGRA_SLEW_SLOW] = "SLOW",
	[TEGRA_SLEW_SLOWEST] = "SLOWEST",
};

static DEFINE_SPINLOCK(mux_lock);

static const char *pingroup_name(enum tegra_pingroup pg)
{
	if (pg < 0 || pg >=  TEGRA_MAX_PINGROUP)
		return "<UNKNOWN>";

	return pingroups[pg].name;
}

static const char *func_name(enum tegra_mux_func func)
{
	if (func == TEGRA_MUX_RSVD1)
		return "RSVD1";

	if (func == TEGRA_MUX_RSVD2)
		return "RSVD2";

	if (func == TEGRA_MUX_RSVD3)
		return "RSVD3";

	if (func == TEGRA_MUX_RSVD4)
		return "RSVD4";

	if (func == TEGRA_MUX_INVALID)
		return "INVALID";

	if (func < 0 || func >=  TEGRA_MAX_MUX)
		return "<UNKNOWN>";

	return tegra_mux_names[func];
}


static const char *tri_name(unsigned long val)
{
	return val ? "TRISTATE" : "NORMAL";
}

static const char *pupd_name(unsigned long val)
{
	switch (val) {
	case 0:
		return "NORMAL";

	case 1:
		return "PULL_DOWN";

	case 2:
		return "PULL_UP";

	default:
		return "RSVD";
	}
}

#if !defined(CONFIG_ARCH_TEGRA_2x_SOC)
static const char *lock_name(unsigned long val)
{
	switch (val) {
	case TEGRA_PIN_LOCK_DEFAULT:
		return "LOCK_DEFUALT";

	case TEGRA_PIN_LOCK_DISABLE:
		return "LOCK_DISABLE";

	case TEGRA_PIN_LOCK_ENABLE:
		return "LOCK_ENABLE";
	default:
		return "LOCK_DEFAULT";
	}
}

static const char *od_name(unsigned long val)
{
	switch (val) {
	case TEGRA_PIN_OD_DEFAULT:
		return "OD_DEFAULT";

	case TEGRA_PIN_OD_DISABLE:
		return "OD_DISABLE";

	case TEGRA_PIN_OD_ENABLE:
		return "OD_ENABLE";
	default:
		return "OD_DEFAULT";
	}
}

static const char *ioreset_name(unsigned long val)
{
	switch (val) {
	case TEGRA_PIN_IO_RESET_DEFAULT:
		return "IO_RESET_DEFAULT";

	case TEGRA_PIN_IO_RESET_DISABLE:
		return "IO_RESET_DISABLE";

	case TEGRA_PIN_IO_RESET_ENABLE:
		return "IO_RESET_ENABLE";
	default:
		return "IO_RESET_DEFAULT";
	}
}
#endif

#if defined(TEGRA_PINMUX_HAS_IO_DIRECTION)
static const char *io_name(unsigned long val)
{
	switch (val) {
	case 0:
		return "OUTPUT";

	case 1:
		return "INPUT";

	default:
		return "RSVD";
	}
}
#endif

static inline unsigned long pg_readl(unsigned long offset)
{
	return readl(IO_TO_VIRT(TEGRA_APB_MISC_BASE + offset));
}

static inline void pg_writel(unsigned long value, unsigned long offset)
{
	writel(value, IO_TO_VIRT(TEGRA_APB_MISC_BASE + offset));
}

static int tegra_pinmux_set_func(const struct tegra_pingroup_config *config)
{
	int mux = -1;
	int i;
	int find = 0;
	unsigned long reg;
	unsigned long flags;
	enum tegra_pingroup pg = config->pingroup;
	enum tegra_mux_func func = config->func;

	if (pg < 0 || pg >=  TEGRA_MAX_PINGROUP)
		return -ERANGE;

	if (pingroups[pg].mux_reg <= 0)
		return -EINVAL;

	if (func == TEGRA_MUX_INVALID) {
		pr_err("The pingroup %s is not recommended for option %s\n",
				pingroup_name(pg), func_name(func));
		WARN_ON(1);
		return -EINVAL;
	}

	if (func < 0)
		return -ERANGE;

	if (func == TEGRA_MUX_SAFE)
		func = pingroups[pg].func_safe;

	if (func & TEGRA_MUX_RSVD) {
		for (i = 0; i < 4; i++) {
			if (pingroups[pg].funcs[i] & TEGRA_MUX_RSVD)
				mux = i;

			if (pingroups[pg].funcs[i] == func) {
				mux = i;
				find = 1;
				break;
			}
		}
	} else {
		for (i = 0; i < 4; i++) {
			if (pingroups[pg].funcs[i] == func) {
				mux = i;
				find = 1;
				break;
			}
		}
	}

	if (mux < 0) {
		pr_err("The pingroup %s is not supported option %s\n",
			pingroup_name(pg), func_name(func));
		WARN_ON(1);
		return -EINVAL;
	}

	if (!find)
		pr_warn("The pingroup %s was configured to %s instead of %s\n",
			pingroup_name(pg), func_name(pingroups[pg].funcs[mux]),
			func_name(func));

	spin_lock_irqsave(&mux_lock, flags);

	reg = pg_readl(pingroups[pg].mux_reg);
	reg &= ~(0x3 << pingroups[pg].mux_bit);
	reg |= mux << pingroups[pg].mux_bit;
#if defined(TEGRA_PINMUX_HAS_IO_DIRECTION)
	reg &= ~(0x1 << 5);
	reg |= ((config->io & 0x1) << 5);
#endif
	pg_writel(reg, pingroups[pg].mux_reg);

	spin_unlock_irqrestore(&mux_lock, flags);

	return 0;
}

static int __maybe_unused tegra_pinmux_get_func(enum tegra_pingroup pg)
{
	int mux = -1;
	unsigned long reg;
	unsigned long flags;

	if (pg < 0 || pg >=  TEGRA_MAX_PINGROUP)
		return -ERANGE;

	if (pingroups[pg].mux_reg <= 0)
		return -EINVAL;

	spin_lock_irqsave(&mux_lock, flags);

	reg = pg_readl(pingroups[pg].mux_reg);
	mux = (reg >> pingroups[pg].mux_bit) & 0x3;

	spin_unlock_irqrestore(&mux_lock, flags);

	return mux;
}

static int tegra_pinmux_set_tristate(enum tegra_pingroup pg,
	enum tegra_tristate tristate)
{
	unsigned long reg;
	unsigned long flags;

	if (pg < 0 || pg >=  TEGRA_MAX_PINGROUP)
		return -ERANGE;

	if (pingroups[pg].tri_reg <= 0)
		return -EINVAL;

	spin_lock_irqsave(&mux_lock, flags);

	reg = pg_readl(pingroups[pg].tri_reg);
	reg &= ~(0x1 << pingroups[pg].tri_bit);
	if (tristate)
		reg |= 1 << pingroups[pg].tri_bit;
	pg_writel(reg, pingroups[pg].tri_reg);

	spin_unlock_irqrestore(&mux_lock, flags);

	return 0;
}

#if !defined(CONFIG_ARCH_TEGRA_2x_SOC)
static int tegra_pinmux_set_lock(enum tegra_pingroup pg,
	enum tegra_pin_lock lock)
{
	unsigned long reg;
	unsigned long flags;

	if (pg < 0 || pg >=  TEGRA_MAX_PINGROUP)
		return -ERANGE;

	if (pingroups[pg].mux_reg <= 0)
		return -EINVAL;

	if ((lock == TEGRA_PIN_LOCK_DEFAULT) || (pingroups[pg].lock_bit < 0))
		return 0;

	spin_lock_irqsave(&mux_lock, flags);

	reg = pg_readl(pingroups[pg].mux_reg);
	reg &= ~(0x1 << pingroups[pg].lock_bit);
	if (lock == TEGRA_PIN_LOCK_ENABLE)
		reg |= (0x1 << pingroups[pg].lock_bit);

	pg_writel(reg, pingroups[pg].mux_reg);

	spin_unlock_irqrestore(&mux_lock, flags);
	return 0;
}

static int tegra_pinmux_set_od(enum tegra_pingroup pg,
	enum tegra_pin_od od)
{
	unsigned long reg;
	unsigned long flags;

	if (pg < 0 || pg >=  TEGRA_MAX_PINGROUP)
		return -ERANGE;

	if (pingroups[pg].mux_reg <= 0)
		return -EINVAL;

	if ((od == TEGRA_PIN_OD_DEFAULT) || (pingroups[pg].od_bit < 0))
		return 0;

	spin_lock_irqsave(&mux_lock, flags);

	reg = pg_readl(pingroups[pg].mux_reg);
	reg &= ~(0x1 << pingroups[pg].od_bit);
	if (od == TEGRA_PIN_OD_ENABLE)
		reg |= 1 << pingroups[pg].od_bit;

	pg_writel(reg, pingroups[pg].mux_reg);

	spin_unlock_irqrestore(&mux_lock, flags);

	return 0;
}

static int tegra_pinmux_set_ioreset(enum tegra_pingroup pg,
	enum tegra_pin_ioreset ioreset)
{
	unsigned long reg;
	unsigned long flags;

	if (pg < 0 || pg >=  TEGRA_MAX_PINGROUP)
		return -ERANGE;

	if (pingroups[pg].mux_reg <= 0)
		return -EINVAL;

	if ((ioreset == TEGRA_PIN_IO_RESET_DEFAULT) || (pingroups[pg].ioreset_bit < 0))
		return 0;

	spin_lock_irqsave(&mux_lock, flags);

	reg = pg_readl(pingroups[pg].mux_reg);
	reg &= ~(0x1 << pingroups[pg].ioreset_bit);
	if (ioreset == TEGRA_PIN_IO_RESET_ENABLE)
		reg |= 1 << pingroups[pg].ioreset_bit;

	pg_writel(reg, pingroups[pg].mux_reg);

	spin_unlock_irqrestore(&mux_lock, flags);

	return 0;
}
#endif

static int tegra_pinmux_set_pullupdown(enum tegra_pingroup pg,
	enum tegra_pullupdown pupd)
{
	unsigned long reg;
	unsigned long flags;

	if (pg < 0 || pg >=  TEGRA_MAX_PINGROUP)
		return -ERANGE;

	if (pingroups[pg].pupd_reg <= 0)
		return -EINVAL;

	if (pupd != TEGRA_PUPD_NORMAL &&
	    pupd != TEGRA_PUPD_PULL_DOWN &&
	    pupd != TEGRA_PUPD_PULL_UP)
		return -EINVAL;


	spin_lock_irqsave(&mux_lock, flags);

	reg = pg_readl(pingroups[pg].pupd_reg);
	reg &= ~(0x3 << pingroups[pg].pupd_bit);
	reg |= pupd << pingroups[pg].pupd_bit;
	pg_writel(reg, pingroups[pg].pupd_reg);

	spin_unlock_irqrestore(&mux_lock, flags);

	return 0;
}

static __maybe_unused void tegra_pinmux_config_pingroup(const struct tegra_pingroup_config *config)
{
	enum tegra_pingroup pingroup = config->pingroup;
	enum tegra_mux_func func     = config->func;
	enum tegra_pullupdown pupd   = config->pupd;
	enum tegra_tristate tristate = config->tristate;
#if !defined(CONFIG_ARCH_TEGRA_2x_SOC)
	enum tegra_pin_lock lock     = config->lock;
	enum tegra_pin_od od         = config->od;
	enum tegra_pin_ioreset ioreset = config->ioreset;
#endif
	int err;

	if (pingroups[pingroup].mux_reg > 0) {
		err = tegra_pinmux_set_func(config);
		if (err < 0)
			pr_err("pinmux: can't set pingroup %s func to %s: %d\n",
			       pingroup_name(pingroup), func_name(func), err);
	}

	if (pingroups[pingroup].pupd_reg > 0) {
		err = tegra_pinmux_set_pullupdown(pingroup, pupd);
		if (err < 0)
			pr_err("pinmux: can't set pingroup %s pullupdown to %s: %d\n",
			       pingroup_name(pingroup), pupd_name(pupd), err);
	}

	if (pingroups[pingroup].tri_reg > 0) {
		err = tegra_pinmux_set_tristate(pingroup, tristate);
		if (err < 0)
			pr_err("pinmux: can't set pingroup %s tristate to %s: %d\n",
			       pingroup_name(pingroup), tri_name(func), err);
	}

#if !defined(CONFIG_ARCH_TEGRA_2x_SOC)
	if (pingroups[pingroup].mux_reg > 0) {
		err = tegra_pinmux_set_lock(pingroup, lock);
		if (err < 0)
			pr_err("pinmux: can't set pingroup %s lock to %s: %d\n",
			       pingroup_name(pingroup), lock_name(func), err);
	}

	if (pingroups[pingroup].mux_reg > 0) {
		err = tegra_pinmux_set_od(pingroup, od);
		if (err < 0)
			pr_err("pinmux: can't set pingroup %s od to %s: %d\n",
			       pingroup_name(pingroup), od_name(func), err);
	}

	if (pingroups[pingroup].mux_reg > 0) {
		err = tegra_pinmux_set_ioreset(pingroup, ioreset);
		if (err < 0)
			pr_err("pinmux: can't set pingroup %s ioreset to %s: %d\n",
			       pingroup_name(pingroup), ioreset_name(func), err);
	}
#endif
}

static const char *drive_pinmux_name(enum tegra_drive_pingroup pg)
{
	if (pg < 0 || pg >=  TEGRA_MAX_DRIVE_PINGROUP)
		return "<UNKNOWN>";

	return drive_pingroups[pg].name;
}

static const char *enable_name(unsigned long val)
{
	return val ? "ENABLE" : "DISABLE";
}

static const char *drive_name(unsigned long val)
{
	if (val >= TEGRA_MAX_DRIVE)
		return "<UNKNOWN>";

	return tegra_drive_names[val];
}

static const char *slew_name(unsigned long val)
{
	if (val >= TEGRA_MAX_SLEW)
		return "<UNKNOWN>";

	return tegra_slew_names[val];
}

static int tegra_drive_pinmux_set_hsm(enum tegra_drive_pingroup pg,
	enum tegra_hsm hsm)
{
	unsigned long flags;
	u32 reg;
	if (pg < 0 || pg >=  TEGRA_MAX_DRIVE_PINGROUP)
		return -ERANGE;

	if (hsm != TEGRA_HSM_ENABLE && hsm != TEGRA_HSM_DISABLE)
		return -EINVAL;

	spin_lock_irqsave(&mux_lock, flags);

	reg = pg_readl(drive_pingroups[pg].reg);
	if (hsm == TEGRA_HSM_ENABLE)
		reg |= (1 << 2);
	else
		reg &= ~(1 << 2);
	pg_writel(reg, drive_pingroups[pg].reg);

	spin_unlock_irqrestore(&mux_lock, flags);

	return 0;
}

static int tegra_drive_pinmux_set_schmitt(enum tegra_drive_pingroup pg,
	enum tegra_schmitt schmitt)
{
	unsigned long flags;
	u32 reg;
	if (pg < 0 || pg >=  TEGRA_MAX_DRIVE_PINGROUP)
		return -ERANGE;

	if (schmitt != TEGRA_SCHMITT_ENABLE && schmitt != TEGRA_SCHMITT_DISABLE)
		return -EINVAL;

	spin_lock_irqsave(&mux_lock, flags);

	reg = pg_readl(drive_pingroups[pg].reg);
	if (schmitt == TEGRA_SCHMITT_ENABLE)
		reg |= (1 << 3);
	else
		reg &= ~(1 << 3);
	pg_writel(reg, drive_pingroups[pg].reg);

	spin_unlock_irqrestore(&mux_lock, flags);

	return 0;
}

static int tegra_drive_pinmux_set_drive(enum tegra_drive_pingroup pg,
	enum tegra_drive drive)
{
	unsigned long flags;
	u32 reg;
	if (pg < 0 || pg >=  TEGRA_MAX_DRIVE_PINGROUP)
		return -ERANGE;

	if (drive < 0 || drive >= TEGRA_MAX_DRIVE)
		return -EINVAL;

	spin_lock_irqsave(&mux_lock, flags);

	reg = pg_readl(drive_pingroups[pg].reg);
	reg &= ~(0x3 << 4);
	reg |= drive << 4;
	pg_writel(reg, drive_pingroups[pg].reg);

	spin_unlock_irqrestore(&mux_lock, flags);

	return 0;
}

static int tegra_drive_pinmux_set_pull_down(enum tegra_drive_pingroup pg,
	enum tegra_pull_strength pull_down)
{
	unsigned long flags;
	u32 reg;

	if (pg < 0 || pg >=  TEGRA_MAX_DRIVE_PINGROUP)
		return -ERANGE;

	if (pull_down < 0 || pull_down >= TEGRA_MAX_PULL)
		return -EINVAL;

	spin_lock_irqsave(&mux_lock, flags);

	reg = pg_readl(drive_pingroups[pg].reg);
	reg &= ~(drive_pingroups[pg].drvdown_mask <<
		drive_pingroups[pg].drvdown_offset);
	reg |= pull_down << drive_pingroups[pg].drvdown_offset;
	pg_writel(reg, drive_pingroups[pg].reg);

	spin_unlock_irqrestore(&mux_lock, flags);

	return 0;
}

static int tegra_drive_pinmux_set_pull_up(enum tegra_drive_pingroup pg,
	enum tegra_pull_strength pull_up)
{
	unsigned long flags;
	u32 reg;

	if (pg < 0 || pg >=  TEGRA_MAX_DRIVE_PINGROUP)
		return -ERANGE;

	if (pull_up < 0 || pull_up >= TEGRA_MAX_PULL)
		return -EINVAL;

	spin_lock_irqsave(&mux_lock, flags);

	reg = pg_readl(drive_pingroups[pg].reg);
	reg &= ~(drive_pingroups[pg].drvup_mask <<
		drive_pingroups[pg].drvup_offset);
	reg |= pull_up << drive_pingroups[pg].drvup_offset;
	pg_writel(reg, drive_pingroups[pg].reg);

	spin_unlock_irqrestore(&mux_lock, flags);

	return 0;
}

static int tegra_drive_pinmux_set_slew_rising(enum tegra_drive_pingroup pg,
	enum tegra_slew slew_rising)
{
	unsigned long flags;
	u32 reg;
	if (pg < 0 || pg >=  TEGRA_MAX_DRIVE_PINGROUP)
		return -ERANGE;

	if (slew_rising < 0 || slew_rising >= TEGRA_MAX_SLEW)
		return -EINVAL;

	spin_lock_irqsave(&mux_lock, flags);

	reg = pg_readl(drive_pingroups[pg].reg);
	reg &= ~(drive_pingroups[pg].slewrise_mask <<
		drive_pingroups[pg].slewrise_offset);
	reg |= slew_rising << drive_pingroups[pg].slewrise_offset;
	pg_writel(reg, drive_pingroups[pg].reg);

	spin_unlock_irqrestore(&mux_lock, flags);

	return 0;
}

static int tegra_drive_pinmux_set_slew_falling(enum tegra_drive_pingroup pg,
	enum tegra_slew slew_falling)
{
	unsigned long flags;
	u32 reg;
	if (pg < 0 || pg >=  TEGRA_MAX_DRIVE_PINGROUP)
		return -ERANGE;

	if (slew_falling < 0 || slew_falling >= TEGRA_MAX_SLEW)
		return -EINVAL;

	spin_lock_irqsave(&mux_lock, flags);

	reg = pg_readl(drive_pingroups[pg].reg);
	reg &= ~(drive_pingroups[pg].slewfall_mask <<
		drive_pingroups[pg].slewfall_offset);
	reg |= slew_falling << drive_pingroups[pg].slewfall_offset;
	pg_writel(reg, drive_pingroups[pg].reg);

	spin_unlock_irqrestore(&mux_lock, flags);

	return 0;
}

static void tegra_drive_pinmux_config_pingroup(enum tegra_drive_pingroup pingroup,
					  enum tegra_hsm hsm,
					  enum tegra_schmitt schmitt,
					  enum tegra_drive drive,
					  enum tegra_pull_strength pull_down,
					  enum tegra_pull_strength pull_up,
					  enum tegra_slew slew_rising,
					  enum tegra_slew slew_falling)
{
	int err;

	err = tegra_drive_pinmux_set_hsm(pingroup, hsm);
	if (err < 0)
		pr_err("pinmux: can't set pingroup %s hsm to %s: %d\n",
			drive_pinmux_name(pingroup),
			enable_name(hsm), err);

	err = tegra_drive_pinmux_set_schmitt(pingroup, schmitt);
	if (err < 0)
		pr_err("pinmux: can't set pingroup %s schmitt to %s: %d\n",
			drive_pinmux_name(pingroup),
			enable_name(schmitt), err);

	err = tegra_drive_pinmux_set_drive(pingroup, drive);
	if (err < 0)
		pr_err("pinmux: can't set pingroup %s drive to %s: %d\n",
			drive_pinmux_name(pingroup),
			drive_name(drive), err);

	err = tegra_drive_pinmux_set_pull_down(pingroup, pull_down);
	if (err < 0)
		pr_err("pinmux: can't set pingroup %s pull down to %d: %d\n",
			drive_pinmux_name(pingroup),
			pull_down, err);

	err = tegra_drive_pinmux_set_pull_up(pingroup, pull_up);
	if (err < 0)
		pr_err("pinmux: can't set pingroup %s pull up to %d: %d\n",
			drive_pinmux_name(pingroup),
			pull_up, err);

	err = tegra_drive_pinmux_set_slew_rising(pingroup, slew_rising);
	if (err < 0)
		pr_err("pinmux: can't set pingroup %s rising slew to %s: %d\n",
			drive_pinmux_name(pingroup),
			slew_name(slew_rising), err);

	err = tegra_drive_pinmux_set_slew_falling(pingroup, slew_falling);
	if (err < 0)
		pr_err("pinmux: can't set pingroup %s falling slew to %s: %d\n",
			drive_pinmux_name(pingroup),
			slew_name(slew_falling), err);
}

static __maybe_unused void tegra_drive_pinmux_config_table(struct tegra_drive_pingroup_config *config,
	int len)
{
	int i;

	for (i = 0; i < len; i++)
		tegra_drive_pinmux_config_pingroup(config[i].pingroup,
						     config[i].hsm,
						     config[i].schmitt,
						     config[i].drive,
						     config[i].pull_down,
						     config[i].pull_up,
						     config[i].slew_rising,
						     config[i].slew_falling);
}

static __maybe_unused void tegra_pinmux_set_safe_pinmux_table(const struct tegra_pingroup_config *config,
	int len)
{
	int i;
	struct tegra_pingroup_config c;

	for (i = 0; i < len; i++) {
		int err;
		c = config[i];
		if (c.pingroup < 0 || c.pingroup >= TEGRA_MAX_PINGROUP) {
			WARN_ON(1);
			continue;
		}
		c.func = pingroups[c.pingroup].func_safe;
		err = tegra_pinmux_set_func(&c);
		if (err < 0)
			pr_err("%s: tegra_pinmux_set_func returned %d setting "
			       "%s to %s\n", __func__, err,
			       pingroup_name(c.pingroup), func_name(c.func));
	}
}

static __maybe_unused void tegra_pinmux_config_pinmux_table(const struct tegra_pingroup_config *config,
	int len)
{
	int i;

	for (i = 0; i < len; i++) {
		int err;
		if (config[i].pingroup < 0 ||
		    config[i].pingroup >= TEGRA_MAX_PINGROUP) {
			WARN_ON(1);
			continue;
		}
		err = tegra_pinmux_set_func(&config[i]);
		if (err < 0)
			pr_err("%s: tegra_pinmux_set_func returned %d setting "
			       "%s to %s\n", __func__, err,
			       pingroup_name(config[i].pingroup),
			       func_name(config[i].func));
	}
}

static __maybe_unused void tegra_pinmux_config_tristate_table(const struct tegra_pingroup_config *config,
	int len, enum tegra_tristate tristate)
{
	int i;
	int err;
	enum tegra_pingroup pingroup;

	for (i = 0; i < len; i++) {
		pingroup = config[i].pingroup;
		if (pingroups[pingroup].tri_reg > 0) {
			err = tegra_pinmux_set_tristate(pingroup, tristate);
			if (err < 0)
				pr_err("pinmux: can't set pingroup %s tristate"
					" to %s: %d\n",	pingroup_name(pingroup),
					tri_name(tristate), err);
		}
	}
}

static __maybe_unused void tegra_pinmux_config_pullupdown_table(const struct tegra_pingroup_config *config,
	int len, enum tegra_pullupdown pupd)
{
	int i;
	int err;
	enum tegra_pingroup pingroup;

	for (i = 0; i < len; i++) {
		pingroup = config[i].pingroup;
		if (pingroups[pingroup].pupd_reg > 0) {
			err = tegra_pinmux_set_pullupdown(pingroup, pupd);
			if (err < 0)
				pr_err("pinmux: can't set pingroup %s pullupdown"
					" to %s: %d\n",	pingroup_name(pingroup),
					pupd_name(pupd), err);
		}
	}
}

#include <linux/debugfs.h>
#include <linux/seq_file.h>

static void dbg_pad_field(struct seq_file *s, int len)
{
	seq_putc(s, ',');

	while (len-- > -1)
		seq_putc(s, ' ');
}

static int dbg_pinmux_show(struct seq_file *s, void *unused)
{
	int i;
	int len;

	for (i = 0; i < TEGRA_MAX_PINGROUP; i++) {
		unsigned long tri;
		unsigned long mux;
		unsigned long pupd;

		if (!pingroups[i].name)
			continue;

		seq_printf(s, "\t{TEGRA_PINGROUP_%s", pingroups[i].name);
		len = strlen(pingroups[i].name);
		dbg_pad_field(s, 15 - len);

		if (pingroups[i].mux_reg <= 0) {
			seq_printf(s, "TEGRA_MUX_NONE");
			len = strlen("NONE");
		} else {
			mux = (pg_readl(pingroups[i].mux_reg) >>
			       pingroups[i].mux_bit) & 0x3;
			BUG_ON(pingroups[i].funcs[mux] == 0);
			if (pingroups[i].funcs[mux] ==  TEGRA_MUX_INVALID) {
				seq_printf(s, "TEGRA_MUX_INVALID");
				len = 7;
			} else if (pingroups[i].funcs[mux] & TEGRA_MUX_RSVD) {
				seq_printf(s, "TEGRA_MUX_RSVD%1lu", mux);
				len = 5;
			} else {
				BUG_ON(!tegra_mux_names[pingroups[i].funcs[mux]]);
				seq_printf(s, "TEGRA_MUX_%s",
					   tegra_mux_names[pingroups[i].funcs[mux]]);
				len = strlen(tegra_mux_names[pingroups[i].funcs[mux]]);
			}
		}
		dbg_pad_field(s, 13-len);

#if defined(TEGRA_PINMUX_HAS_IO_DIRECTION)
		{
			unsigned long io;
			io = (pg_readl(pingroups[i].mux_reg) >> 5) & 0x1;
			seq_printf(s, "TEGRA_PIN_%s", io_name(io));
			len = strlen(io_name(io));
			dbg_pad_field(s, 6 - len);
		}
#endif
		if (pingroups[i].pupd_reg <= 0) {
			seq_printf(s, "TEGRA_PUPD_NORMAL");
			len = strlen("NORMAL");
		} else {
			pupd = (pg_readl(pingroups[i].pupd_reg) >>
				pingroups[i].pupd_bit) & 0x3;
			seq_printf(s, "TEGRA_PUPD_%s", pupd_name(pupd));
			len = strlen(pupd_name(pupd));
		}
		dbg_pad_field(s, 9 - len);

		if (pingroups[i].tri_reg <= 0) {
			seq_printf(s, "TEGRA_TRI_NORMAL");
		} else {
			tri = (pg_readl(pingroups[i].tri_reg) >>
			       pingroups[i].tri_bit) & 0x1;

			seq_printf(s, "TEGRA_TRI_%s", tri_name(tri));
		}
		seq_printf(s, "},\n");
	}
	return 0;
}

static int dbg_pinmux_open(struct inode *inode, struct file *file)
{
	return single_open(file, dbg_pinmux_show, &inode->i_private);
}

static const struct file_operations debug_fops = {
	.open		= dbg_pinmux_open,
	.read		= seq_read,
	.llseek		= seq_lseek,
	.release	= single_release,
};

static int dbg_drive_pinmux_show(struct seq_file *s, void *unused)
{
	int i;
	int len;
	u8 offset;

	for (i = 0; i < TEGRA_MAX_DRIVE_PINGROUP; i++) {
		u32 reg;

		seq_printf(s, "\t{TEGRA_DRIVE_PINGROUP_%s",
			drive_pingroups[i].name);
		len = strlen(drive_pingroups[i].name);
		dbg_pad_field(s, 7 - len);


		reg = pg_readl(drive_pingroups[i].reg);
		if (HSM_EN(reg)) {
			seq_printf(s, "TEGRA_HSM_ENABLE");
			len = 16;
		} else {
			seq_printf(s, "TEGRA_HSM_DISABLE");
			len = 17;
		}
		dbg_pad_field(s, 17 - len);

		if (SCHMT_EN(reg)) {
			seq_printf(s, "TEGRA_SCHMITT_ENABLE");
			len = 21;
		} else {
			seq_printf(s, "TEGRA_SCHMITT_DISABLE");
			len = 22;
		}
		dbg_pad_field(s, 22 - len);

		seq_printf(s, "TEGRA_DRIVE_%s", drive_name(LPMD(reg)));
		len = strlen(drive_name(LPMD(reg)));
		dbg_pad_field(s, 5 - len);

		offset = drive_pingroups[i].drvdown_offset;
		seq_printf(s, "TEGRA_PULL_%d", DRVDN(reg, offset));
		len = DRVDN(reg, offset) < 10 ? 1 : 2;
		dbg_pad_field(s, 2 - len);

		offset = drive_pingroups[i].drvup_offset;
		seq_printf(s, "TEGRA_PULL_%d", DRVUP(reg, offset));
		len = DRVUP(reg, offset) < 10 ? 1 : 2;
		dbg_pad_field(s, 2 - len);

		offset = drive_pingroups[i].slewrise_offset;
		seq_printf(s, "TEGRA_SLEW_%s", slew_name(SLWR(reg, offset)));
		len = strlen(slew_name(SLWR(reg, offset)));
		dbg_pad_field(s, 7 - len);

		offset= drive_pingroups[i].slewfall_offset;
		seq_printf(s, "TEGRA_SLEW_%s", slew_name(SLWF(reg, offset)));

		seq_printf(s, "},\n");
	}
	return 0;
}

static int dbg_drive_pinmux_open(struct inode *inode, struct file *file)
{
	return single_open(file, dbg_drive_pinmux_show, &inode->i_private);
}

static const struct file_operations debug_drive_fops = {
	.open		= dbg_drive_pinmux_open,
	.read		= seq_read,
	.llseek		= seq_lseek,
	.release	= single_release,
};

static int __init tegra_pinmux_debuginit(void)
{
	if (!of_machine_is_compatible("nvidia,tegra114"))
		return 0;

	(void) debugfs_create_file("tegra_pinmux", S_IRUGO,
					NULL, NULL, &debug_fops);
	(void) debugfs_create_file("tegra_pinmux_drive", S_IRUGO,
					NULL, NULL, &debug_drive_fops);
	return 0;
}
late_initcall(tegra_pinmux_debuginit);
